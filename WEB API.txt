1.API公开
2.编制一套数据库访问机制
3.URI设计
	短小便于输入
	可以秒懂
	编码拼写错误
	全部小写
	易修改
	不会暴露服务器端架构（服务软件、语言等信息）
	规则统一（id都放在uri里，单复数一致）

4.HTTP方法 和 URI
	http方法：进行怎样的操作
	URI：操作的对象（资源）

5.http请求方法之间的区别
	post：生成新的资源
	put：全部更新已存在的资源
	patch：部分更新已存在的资源

6.兼容只支持post/get方式的客户端
	6.1 表单中加入_method参数 （依赖 application/x-www-form-urlencoded 媒体类型发送数据）

	6.2 X-HTTP-Method-Override的HTTP请求头部

	这两个方法大部分框架中都支持。

7.API端点设计
	7.1 使用资源的复数形式

	7.2 不适用空格及需要编码的字符

	7.3 多个单词之间用连字符 '-' 

	7.4 搜索和查询参数 在查询字符串中定义

	7.5 分页 
		page/per_page  缓存效率有效

		limit/offset  组合自由度更高


8.查询参数与路径的使用区别
	在路径中使用依据：
		1. 是否是表示唯一资源所需的信息

		2. 是否可以省略


9.获取自身信息
	通过token获取用户信息
	9.1 /user/self

	9.2 /user/me

10.OAuth
	url: https://api.example.com/v1/oauth2/token

	client_id、client_secret 获取token、refresh_token(用于重新获取token)

	token有效期expires_in(过期时间)，无效返回401 

11.	HATEOAS
	超媒体即应用状态引擎
	HATEOAS会在API返回的数据中包含下一步要执行的行为、要获取的数据等URI的链接信息。
	url以及对应的rel解释信息。

12.数据格式指定
	12.1 请求参数指定 （不推荐）

	12.2 URI最后添加上扩展 .json或.xml

	12.3 使用 Accept的请求首部

13.跨域处理
	jsonp

	Access-Control-Allow-Origin

14.数据内部的思考
	14.1 尽量减少http的请求次数

	14.2 响应字段可选择（请求参数中加入fields）
15.数据响应
	15.1 http状态合理使用

	15.2 层级化与扁平化合理选择（数据尽可能扁平化）

	15.3 响应的数据对于分页展示的不一定要计算总数（服务端可以在每页显示的数量上+1，得知是否有下一页），并且接口应返回下一页的相关信息（是否存在下一页...）

	15.4 避免数值溢出问题（添加一个字符串返回值）

16.API版本管理
	16.1 版本编号定义
		1.2.3  
		3位数字分别对应： 主版本编号、次版本编号、 补丁版本编号
		修改规则：
			补丁版本编号： API没有发生变更，只修正了部分bug
			次版本编号  ： 对软件进行向下兼容的变更或废除某些特定的功能时
			主版本编号  ： 不向下兼容的变更

		可以考虑只取两位数字或一位数字来作为版本号，维护版本减少